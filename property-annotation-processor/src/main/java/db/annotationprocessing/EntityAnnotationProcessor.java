package db.annotationprocessing;


import javax.annotation.processing.AbstractProcessor;
import javax.annotation.processing.Messager;
import javax.annotation.processing.ProcessingEnvironment;
import javax.annotation.processing.RoundEnvironment;
import javax.annotation.processing.SupportedAnnotationTypes;
import javax.annotation.processing.SupportedSourceVersion;
import javax.lang.model.SourceVersion;
import javax.lang.model.element.AnnotationMirror;
import javax.lang.model.element.Element;
import javax.lang.model.element.ExecutableElement;
import javax.lang.model.element.Name;
import javax.lang.model.element.TypeElement;
import javax.lang.model.type.DeclaredType;
import javax.lang.model.type.PrimitiveType;
import javax.lang.model.type.ReferenceType;
import javax.lang.model.type.TypeMirror;
import javax.lang.model.util.ElementScanner6;
import javax.lang.model.util.Elements;
import javax.lang.model.util.Types;
import javax.tools.Diagnostic.Kind;
import javax.tools.FileObject;
import javax.tools.StandardLocation;
import java.beans.Introspector;
import java.io.IOException;
import java.io.Writer;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashSet;
import java.util.List;
import java.util.Set;


@SupportedAnnotationTypes({"javax.persistence.Entity", "to.etc.annotations.GenerateProperties"})
@SupportedSourceVersion(SourceVersion.RELEASE_8)
/**
 * Generates QField classes for every Entity annotated class in the project where this processor is selected.
 * Leave the default .apt_generated folder as is.
 *
 * With great gratitude to:
 * <ul>
 *     <li>http://hannesdorfmann.com/annotation-processing/annotationprocessing101</li>
 * </ul>
 *
 * @author <a href="mailto:dennis.bekkering@itris.nl">Dennis Bekkering</a>
 * Created on Feb 3, 2013
 */
public class EntityAnnotationProcessor extends AbstractProcessor {
	static public final String VERSION = "1.0";

	private static final String PRE_FIX = "P";

	private Types m_typeUtils;

	private Elements m_elementUtils;

	static public final class Property {
		private final TypeMirror m_type;

		private final String m_name;

		private final Set<String> m_annotationNames;

		public Property(TypeMirror type, String name, Set<String> annotationNames) {
			m_type = type;
			m_name = name;
			m_annotationNames = annotationNames;
		}

		public TypeMirror getType() {
			return m_type;
		}

		public String getName() {
			return m_name;
		}

		public Set<String> getAnnotationNames() {
			return m_annotationNames;
		}
	}

	public EntityAnnotationProcessor() {
		super();
	}

	@Override public synchronized void init(ProcessingEnvironment processingEnv) {
		super.init(processingEnv);
		m_typeUtils = processingEnv.getTypeUtils();
		m_elementUtils = processingEnv.getElementUtils();
	}

	public Types getTypeUtils() {
		return m_typeUtils;
	}

	public Elements getElementUtils() {
		return m_elementUtils;
	}

	@Override
	public boolean process(Set< ? extends TypeElement> annotations, RoundEnvironment roundEnv) {
		if(roundEnv.processingOver()) {
			return false;
		}

		final Messager messager = processingEnv.getMessager();
		Set<Element> done = new HashSet<>();
		for(TypeElement ann : annotations) {
			Set< ? extends Element> rootElements = roundEnv.getElementsAnnotatedWith(ann);
			for(Element classElement : rootElements) {
				if(! done.add(classElement))
					continue;

				String pack = processingEnv.getElementUtils().getPackageOf(classElement).getQualifiedName().toString();
				String entityName = classElement.getSimpleName().toString();

				//String entityName = classElement.asType().toString();
				try {
					List<Property> properties = getProperties(classElement);

					generateMainClass(pack, entityName, classElement, ann, properties);
					generateRootClass(pack, entityName, classElement, ann, properties);
				} catch(Exception e1) {
					e1.printStackTrace();
					messager.printMessage(Kind.ERROR, e1.toString() + " in " + getClass(), classElement);
				}
			}
		}
		return false;
	}

	public String getRootClass(String entityName) {
		return entityName + "_";						// Artist becomes Artist_
	}

	public String getLinkClass(String entityName) {
		return "Helper" + entityName;
	}

	private void generateRootClass(String pack, String cname, Element classElement, TypeElement ann, List<Property> properties) throws Exception {
		//ROOT CLASS
		FileObject jf2 = processingEnv.getFiler().createResource(StandardLocation.SOURCE_OUTPUT, pack, PRE_FIX + classElement.getSimpleName() + "Root.java", ann);
		String qname = PRE_FIX + cname;

		try(Writer w = jf2.openWriter()) {
			new ClassGenerator(this, w, pack, getRootClass(cname), properties, cname).generate();
			//
			//
			//w.append("package ").append(pack).append(";\n");
			//w.append("\n");
			//w.append("import to.etc.webapp.query.*;\n");
			//w.append("import javax.annotation.*;\n");
			//w.append("\n");
			//w.append("@Generated(value = { \"Generated by etc.to PropertyAnnotationProcessor " + VERSION + "\" })\n");
			//w.append("public final class ");
			//w.append(qname);
			//w.append("Root extends ");
			//w.append(qname);
			//w.append("<");
			//w.append(qname);
			//w.append("Root> {\n\n\t");
			//w.append(qname);
			//w.append("Root() {\n\t\tsuper(null, null, null);\n\t}\n\n\t");
			//
			//w.append("@Nonnull public QCriteria<");
			//w.append(cname);
			//w.append("> getCriteria() throws Exception {\n\t\t");
			//w.append("validateGetCriteria();\n\t\t");
			//w.append("return (QCriteria<");
			//w.append(cname);
			//w.append(">) criteria();\n\t}");
			//
			//w.append("\n}");
		}
	}


	private void generateMainClass(String pack, String cname, Element classElement, TypeElement ann, List<Property> properties) throws Exception {
		FileObject jf = processingEnv.getFiler().createResource(StandardLocation.SOURCE_OUTPUT, pack, PRE_FIX + classElement.getSimpleName() + ".java", ann);

		String qname = PRE_FIX + cname;
		try(Writer w = jf.openWriter()) {
			w.append("package ").append(pack).append(";\n");
			w.append("\n");
			w.append("import to.etc.webapp.query.*;\n");
			w.append("import javax.annotation.*;\n");
			w.append("\n");
			w.append("@Generated(value = { \"Generated by etc.to PropertyAnnotationProcessor " + VERSION + ".\" })\n");
			w.append("public class ");
			w.append(qname);
			w.append("<R extends QField<R, ? >> extends QField<R,");
			w.append(cname);
			w.append("> {\n\n\tpublic ");
			w.append(qname);
			w.append("(@Nullable R root, @Nullable QField<R, ? > parent, @Nullable String name) {");
			w.append("\n\t\tsuper(root, parent, name);\n\t}");

			Element ce = classElement;

			while(ce != null && !ce.toString().equals("java.lang.Object")) {
				final Messager messager = processingEnv.getMessager();

				ElementScanner6 v = new Visitor(w, messager, qname);
				ce.accept(v, null);
				TypeElement asType = (TypeElement) ce;
				DeclaredType sup = (DeclaredType) asType.getSuperclass();
				ce = sup == null ? null : sup.asElement();
			}

			w.append("\n\n\t@Nonnull\n\tpublic static final ");
			w.append(qname);
			w.append("Root get() {\n\t\treturn new ");
			w.append(qname);
			w.append("Root();\n\t}");
			w.append("\n}");
		}
	}

	private List<Property> getProperties(Element classElement) throws Exception {
		Element ce = classElement;

		List<Property> result = new ArrayList<>();
		while(ce != null && !ce.toString().equals("java.lang.Object")) {
			final Messager messager = processingEnv.getMessager();

			PropertyVisitor v = new PropertyVisitor();
			ce.accept(v, null);
			result.addAll(v.getResult());
			TypeElement asType = (TypeElement) ce;
			DeclaredType sup = (DeclaredType) asType.getSuperclass();
			ce = sup == null ? null : sup.asElement();
		}
		return result;
	}

	/**
	 * True if the type is a simple type (any primitive or primitive wrapper, Date, BigDecimal, BigInteger, String, Enum).
	 */
	private boolean isSimpleType(TypeMirror type) {
		if(type instanceof PrimitiveType)
			return true;
		TypeElement enumElement = m_elementUtils.getTypeElement("java.lang.Enum");

		if(m_typeUtils.isSubtype(type, m_typeUtils.getDeclaredType(enumElement)))
			return true;

		String name = type.toString();
		return SIMPLETYPES.contains(name);
	}

	private boolean isCollection(TypeMirror type) {
		if(! (type instanceof ReferenceType))
			return false;
		TypeElement enumElement = m_elementUtils.getTypeElement("java.util.Collection");
		if(m_typeUtils.isSubtype(type, m_typeUtils.getDeclaredType(enumElement)))
			return true;
		return false;
	}

	private final class PropertyVisitor extends ElementScanner6 {
		private final List<Property> m_result = new ArrayList<>();

		private PropertyVisitor() {
		}

		public List<Property> getResult() {
			return m_result;
		}

		/**
		 * Visits a single method.
		 */
		@Override
		public Object visitExecutable(ExecutableElement m, Object p) {
			//-- We accept only the getters, isxxx and getxxxx
			String methodName = m.getSimpleName().toString();
			String propertyName;
			if(methodName.startsWith("is")) {
				propertyName = Introspector.decapitalize(methodName.substring(2));
			} else if(methodName.startsWith("get")) {
				propertyName = Introspector.decapitalize(methodName.substring(3));
			} else {
				return super.visitExecutable(m, p);
			}

			TypeMirror returnType = m.getReturnType();
			if(returnType instanceof javax.lang.model.type.NoType) {	// void?
				return super.visitExecutable(m, p);
			}

			//-- Get a set of annotation names
			Set<String> annotationNames = new HashSet<>();
			for(AnnotationMirror a : m.getAnnotationMirrors()) {
				Name annName = a.getAnnotationType().asElement().getSimpleName();
				annotationNames.add(annName.toString());
			}
			if(annotationNames.contains("to.etc.annotations.IgnoreGeneration")) {	// Ignore?
				return super.visitExecutable(m, p);
			}

			m_result.add(new Property(returnType, propertyName, annotationNames));
			return super.visitExecutable(m, p);
		}
	}



	private final class Visitor extends ElementScanner6 {
		private final Writer m_w;

		private final Messager m_messager;

		private String m_qname;

		private Visitor(Writer w, Messager messager, String qname) {
			m_w = w;
			m_messager = messager;
			m_qname = qname;
		}

		private void generateColumnProperty(TypeMirror returnType, String propertyName) throws Exception {
			String mname = replaceReserved(propertyName);
			if(returnType instanceof PrimitiveType) {
				String retStr = returnType.toString();
				if(retStr.equals("int") || retStr.equals("short")) {
					retStr = "long";
				}
				String mtypeName = Character.toUpperCase(retStr.charAt(0)) + retStr.substring(1);
				m_w.append("\n\n\t@Nonnull\n\tpublic final QField");
				m_w.append(mtypeName);
				m_w.append("<R> ");
				m_w.append(mname);
				m_w.append("() {\n\t\treturn new QField");
				m_w.append(mtypeName);
				m_w.append("<R>(new QField<R, ");
				m_w.append(retStr);
				m_w.append("[]>(m_root, this, \"");
				m_w.append(propertyName);
				m_w.append("\"));\n\t}");

			} else {
				String mtypeName = returnType.toString();

				m_w.append("\n\n\t@Nonnull\n\tpublic final QField<R,");
				m_w.append(mtypeName);
				m_w.append("> ");
				m_w.append(mname);
				m_w.append("() {\n\t\treturn new QField<R,");
				m_w.append(mtypeName);
				m_w.append(">(m_root, this, \"");
				m_w.append(propertyName);
				m_w.append("\");\n\t}");
			}
		}

		private void generateParentProperty(TypeMirror returnType, String propertyName) throws Exception {
			Element mtype = processingEnv.getTypeUtils().asElement(returnType);
			String qtype = packName(returnType.toString()) + "." + PRE_FIX + mtype.getSimpleName().toString();

			String mname = replaceReserved(propertyName);
			m_w.append("\n\n\t@Nonnull\n\tpublic final ");
			m_w.append(qtype);
			m_w.append("<R> ");
			m_w.append(mname);
			m_w.append("() {\n\t\treturn new ");
			m_w.append(qtype);
			m_w.append("<R>(m_root, this, \"");
			m_w.append(propertyName);
			m_w.append("\");\n\t}");
		}

		private void generateListProperty(TypeMirror returnType, String propertyName) throws Exception {
			DeclaredType rtype = (DeclaredType) returnType;

			DeclaredType rtypeArg = (DeclaredType) rtype.getTypeArguments().iterator().next();
			String rtypeArgName = rtypeArg.asElement().getSimpleName().toString();
			String frtypeArgName = rtypeArg.toString();

			String pack = packName(frtypeArgName);

			String qrtypeArgName = pack + "." + PRE_FIX + rtypeArgName;

			String mname = replaceReserved(propertyName);
			m_w.append("\n\n\t@Nonnull\n\tpublic final QList<R,");
			m_w.append(qrtypeArgName);
			m_w.append("Root> ");
			m_w.append(mname);
			m_w.append("() throws Exception {\n\t\treturn new QList<R,");
			m_w.append(qrtypeArgName);
			m_w.append("Root>(");
			m_w.append(qrtypeArgName);
			m_w.append(".get(), this, \"");
			m_w.append(propertyName);
			m_w.append("\");\n\t}");
		}

		/**
		 * Visits a single method.
		 */
		@Override
		public Object visitExecutable(ExecutableElement m, Object p) {
			try {
				//-- We accept only the getters, isxxx and getxxxx
				String methodName = m.getSimpleName().toString();
				String propertyName;
				if(methodName.startsWith("is")) {
					propertyName = Introspector.decapitalize(methodName.substring(2));
				} else if(methodName.startsWith("get")) {
					propertyName = Introspector.decapitalize(methodName.substring(3));
				} else {
					return super.visitExecutable(m, p);
				}

				TypeMirror returnType = m.getReturnType();
				if(returnType instanceof javax.lang.model.type.NoType) {	// void?
					return super.visitExecutable(m, p);
				}

				//-- Get a set of annotation names
				Set<String> annotationNames = new HashSet<>();
				for(AnnotationMirror a : m.getAnnotationMirrors()) {
					Name annName = a.getAnnotationType().asElement().getSimpleName();
					annotationNames.add(annName.toString());
				}
				if(annotationNames.contains("to.etc.annotations.IgnoreGeneration")) {	// Ignore?
					return super.visitExecutable(m, p);
				}


				//-- Now generate the appropriate types.
				if(annotationNames.contains("Column") || isSimpleType(returnType)) {
					generateColumnProperty(returnType, propertyName);
				} else if(annotationNames.contains("ManyToOne")) {
					generateParentProperty(returnType, propertyName);
				} else if(annotationNames.contains("OneToMany") || isCollection(returnType)) {
					generateListProperty(returnType, propertyName);
				}


				//List< ? extends AnnotationMirror> annotationMirrors = m.getAnnotationMirrors();
				//for(AnnotationMirror a : annotationMirrors) {
				//	if(annName.toString().equals("ManyToOne") || annName.toString().equals("Column")) {
				//		String mname = m.getSimpleName().toString();
				//		if(mname.startsWith("is")) {
				//			mname = Character.toLowerCase(mname.charAt(2)) + mname.substring(3);
				//		} else {
				//			mname = Character.toLowerCase(mname.charAt(3)) + mname.substring(4);
				//		}
				//		TypeMirror returnType = m.getReturnType();
				//
				//		String mtypeName;
				//		if(returnType instanceof PrimitiveType) {
				//			mtypeName = returnType.toString();
				//			if(mtypeName.equals("int") || mtypeName.equals("short")) {
				//				mtypeName = "long";
				//			}
				//
				//		} else {
				//			Element mtype = processingEnv.getTypeUtils().asElement(returnType);
				//			//mtypeName = mtype.getSimpleName().toString();
				//			mtypeName = m.getReturnType().toString();
				//		}
				//
				//		mname = replaceReserved(mname);
				//
				//		m_w.append("\n\n\t/**\n\t");
				//		m_w.append(" * Shortcut eq\n\t");
				//		m_w.append(" * @param ");
				//		m_w.append(mname);
				//		m_w.append("\n\t");
				//		m_w.append(" * @return\n\t");
				//		m_w.append(" */\n\t@Nonnull\n\tpublic final R ");
				//		m_w.append(mname);
				//		m_w.append("(@Nonnull ");
				//		m_w.append(mtypeName);
				//		m_w.append("... ");
				//		m_w.append(mname);
				//		m_w.append(") {\n\t\treturn ");
				//		m_w.append(mname);
				//		m_w.append("().eq(");
				//		m_w.append(mname);
				//		m_w.append(");\n\t}");
				//	}
				//
				//
				//}


			} catch(Exception e1) {
				e1.printStackTrace();
				try {
					m_w.append(e1.toString());
				} catch(IOException ioe) {
					e1.printStackTrace();
				}
				m_messager.printMessage(Kind.ERROR, e1.toString() + " in " + getClass(), m);

			}
			return super.visitExecutable(m, p);
		}

		/**
		 * True if the type is a simple type (any primitive or primitive wrapper, Date, BigDecimal, BigInteger, String, Enum).
		 */
		private boolean isSimpleType(TypeMirror type) {
			if(type instanceof PrimitiveType)
				return true;
			TypeElement enumElement = m_elementUtils.getTypeElement("java.lang.Enum");

			if(m_typeUtils.isSubtype(type, m_typeUtils.getDeclaredType(enumElement)))
				return true;

			String name = type.toString();
			return SIMPLETYPES.contains(name);
		}

		private boolean isCollection(TypeMirror type) {
			if(! (type instanceof ReferenceType))
				return false;
			TypeElement enumElement = m_elementUtils.getTypeElement("java.util.Collection");
			if(m_typeUtils.isSubtype(type, m_typeUtils.getDeclaredType(enumElement)))
				return true;
			return false;
		}

		private String packName(String frtypeArgName) {
			int dotIndex = frtypeArgName.lastIndexOf('.');
			String pack = "";
			if(dotIndex != -1) {
				pack = frtypeArgName.substring(0, dotIndex);
			}
			return pack;
		}
	}


	static String replaceReserved(String s) {
		if(m_reserved.contains(s)) {
			return s + "_";
		}
		return s;
	}

	static private final Set<String> SIMPLETYPES = new HashSet<>(Arrays.asList("java.lang.Short"
		, "java.lang.Boolean"
		, "java.lang.Byte"
		, "java.lang.Character"
		, "java.lang.Integer"
		, "java.lang.Long"
		, "java.lang.Float"
		, "java.lang.Double"
		, "java.math.BigInteger"
		, "java.math.BigDecimal"
		, "java.lang.String"
		, "java.util.Date"
		, "java.sql.Date"
	));

	static final Set<String> m_reserved = new HashSet<String>();

	static {
		m_reserved.add("abstract");
		m_reserved.add("assert");
		m_reserved.add("boolean ");
		m_reserved.add("break ");
		m_reserved.add("byte");
		m_reserved.add("case");
		m_reserved.add("catch");
		m_reserved.add("char");
		m_reserved.add("class");
		m_reserved.add("const");
		m_reserved.add("continue");
		m_reserved.add("default");
		m_reserved.add("double");
		m_reserved.add("do");
		m_reserved.add("else");
		m_reserved.add("enum");
		m_reserved.add("extends");
		m_reserved.add("false");
		m_reserved.add("final");
		m_reserved.add("finally");
		m_reserved.add("float");
		m_reserved.add("for");
		m_reserved.add("goto");
		m_reserved.add("if");
		m_reserved.add("implements");
		m_reserved.add("import");
		m_reserved.add("instanceof");
		m_reserved.add("int");
		m_reserved.add("interface");
		m_reserved.add("long");
		m_reserved.add("native");
		m_reserved.add("new");
		m_reserved.add("null");
		m_reserved.add("package");
		m_reserved.add("private");
		m_reserved.add("protected");
		m_reserved.add("public");
		m_reserved.add("return");
		m_reserved.add("short");
		m_reserved.add("static");
		m_reserved.add("strictfp");
		m_reserved.add("super");
		m_reserved.add("switch");
		m_reserved.add("synchronized");
		m_reserved.add("this");
		m_reserved.add("throw");
		m_reserved.add("throws");
		m_reserved.add("transient");
		m_reserved.add("true");
		m_reserved.add("try");
		m_reserved.add("void");
		m_reserved.add("volatile");
		m_reserved.add("while");

	}
}
