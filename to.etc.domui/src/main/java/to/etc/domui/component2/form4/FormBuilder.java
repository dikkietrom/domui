package to.etc.domui.component2.form4;

import org.eclipse.jdt.annotation.NonNull;
import org.eclipse.jdt.annotation.Nullable;
import to.etc.domui.component.binding.BindReference;
import to.etc.domui.component.binding.IBidiBindingConverter;
import to.etc.domui.component.meta.MetaManager;
import to.etc.domui.component.meta.PropertyMetaModel;
import to.etc.domui.component2.controlfactory.ControlCreatorRegistry;
import to.etc.domui.dom.html.BindingBuilderBidi;
import to.etc.domui.dom.html.IControl;
import to.etc.domui.dom.html.Label;
import to.etc.domui.dom.html.NodeBase;
import to.etc.domui.dom.html.NodeContainer;
import to.etc.domui.server.DomApplication;
import to.etc.domui.util.DomUtil;
import to.etc.webapp.ProgrammerErrorException;
import to.etc.webapp.annotations.GProperty;
import to.etc.webapp.query.QField;

/**
 * Yet another attempt at a generic form builder, using the Builder pattern. The builder
 * starts in vertical mode - call horizontal() to move horizontally.
 *
 * @author <a href="mailto:jal@etc.to">Frits Jalvingh</a>
 * Created on Jun 17, 2014
 */
final public class FormBuilder {
	/**
	 * Handle adding nodes generated by the form builder to the page.
	 *
	 * @author <a href="mailto:jal@etc.to">Frits Jalvingh</a>
	 * Created on Jun 13, 2012
	 */
	interface IAppender {
		void add(@NonNull NodeBase formNode);
	}

	@NonNull
	final private IAppender m_appender;

	private IFormLayouter m_layouter;

	private boolean m_horizontal;

	private boolean m_append;

	private boolean m_currentDirection;

	/** While set, all controls added will have their readOnly property bound to this reference unless otherwise specified */
	@Nullable
	private BindReference<?, Boolean> m_readOnlyGlobal;

	@Nullable
	private BindReference<?, String> m_disabledMessageGlobal;

	@Nullable
	private BindReference<?, Boolean> m_disabledGlobal;

	public FormBuilder(@NonNull IAppender appender) {
		m_appender = appender;
		m_layouter = new ResponsiveFormLayouter(appender);
//		m_layouter = new TableFormLayouter(appender);
	}

	public FormBuilder(@NonNull IFormLayouter layout, @NonNull IAppender appender) {
		m_appender = appender;
		m_layouter = layout;
	}

	public FormBuilder(@NonNull final NodeContainer nb) {
		this(nb::add);
	}

	@NonNull
	public FormBuilder append() {
		m_append = true;
		return this;
	}


	public FormBuilder nl() {
		m_layouter.clear();
		return this;
	}

	@NonNull
	public FormBuilder horizontal() {
		m_horizontal = true;
		m_layouter.setHorizontal(true);
		return this;
	}

	@NonNull
	public FormBuilder vertical() {
		m_horizontal = false;
		m_layouter.setHorizontal(false);
		return this;
	}

	static private <I, V> BindReference<I, V> createRef(@NonNull I instance, @NonNull String property, @NonNull Class<V> type) {
		PropertyMetaModel<?> pmm = MetaManager.getPropertyMeta(instance.getClass(), property);
		if(DomUtil.getBoxedForPrimitive(pmm.getActualType()) != DomUtil.getBoxedForPrimitive(type)) {
			throw new ProgrammerErrorException(pmm + " must be of type " + type.getName());
		}
		return new BindReference<>(instance, (PropertyMetaModel<V>) pmm);

	}

	static private <I, V> BindReference<I, V> createRef(@NonNull I instance, @NonNull QField<I, V> property) {
		PropertyMetaModel<V> pmm = MetaManager.getPropertyMeta(instance.getClass(), property);
		//if(DomUtil.getBoxedForPrimitive(pmm.getActualType()) != DomUtil.getBoxedForPrimitive(property.)) {
		//	throw new ProgrammerErrorException(pmm + " must be of type " + type.getName());
		//}
		return new BindReference<>(instance, pmm);
	}


	/**
	 * By default bind all next components' readOnly property to the specified Boolean property. This binding
	 * takes effect except if a more detailed readOnly binding is specified.
	 */
	@NonNull
	public <I> FormBuilder readOnlyAll(@NonNull I instance, @NonNull String property) {
		m_readOnlyGlobal = createRef(instance, property, Boolean.class);
		return this;
	}

	/**
	 * Clear the global "read only" binding as set by {@link #readOnlyAll(Object, String)}, so that components
	 * after this are no longer bound to the previously set property.
	 */
	@NonNull
	public FormBuilder readOnlyAllClear() {
		m_readOnlyGlobal = null;
		return this;
	}

	/**
	 * By default bind all next components' disabled property to the specified Boolean property. This binding
	 * takes effect except if a more detailed binding is specified.
	 */
	@NonNull
	public <I> FormBuilder disabledAll(@NonNull I instance, @NonNull String property) {
		m_disabledGlobal = createRef(instance, property, Boolean.class);
		return this;
	}

	/**
	 * Clear the global "disabled" binding as set by {@link #disabledAll(Object, String)}, so that components
	 * after this are no longer bound to the previously set property.
	 */
	@NonNull
	public FormBuilder disabledAllClear() {
		m_disabledGlobal = null;
		return this;
	}

	@NonNull
	public <I> FormBuilder disabledBecauseAll(@NonNull I instance, @NonNull String property) {
		m_disabledMessageGlobal = createRef(instance, property, String.class);
		return this;
	}

	@NonNull
	public FormBuilder disabledBecauseClear() {
		m_disabledMessageGlobal = null;
		return this;
	}

	/*--------------------------------------------------------------*/
	/*	CODING: defining (manually created) controls.				*/
	/*--------------------------------------------------------------*/
	/**
	 * Add the specified control. Since the control is manually created this code assumes that the
	 * control is <b>properly configured</b> for it's task! This means that this code will not
	 * make any changes to the control! Specifically: if the form item is marked as "mandatory"
	 * but the control here is not then the control stays optional.
	 * The reverse however is not true: if the control passed in is marked as mandatory then the
	 * form item will be marked as such too.
	 */
	public void control(@NonNull IControl< ? > control) throws Exception {
		if(control.isMandatory()) {
			m_mandatory = Boolean.TRUE;
		}
		addControl((NodeBase) control);
		resetBuilder();
	}

	@NonNull
	public IControl< ? > control() throws Exception {
		return controlMain(null);
	}

	@NonNull
	public <T, C extends IControl<T>> C control(@Nullable Class<C> controlClass) throws Exception {
		return controlMain(controlClass);
	}

	@NonNull
	private  <T, C extends IControl<T>> C controlMain(@Nullable Class<C> controlClass) throws Exception {
		ControlCreatorRegistry builder = DomApplication.get().getControlCreatorRegistry();
		PropertyMetaModel<T> pmm = (PropertyMetaModel<T>) m_propertyMetaModel;
		if(null == pmm)
			throw new IllegalStateException("You must have called 'property(...)' before");
		C control = builder.createControl(pmm, controlClass);
		addControl((NodeBase) control);
		resetBuilder();
		return control;
	}

	public void item(@NonNull NodeBase item) throws Exception {
		addControl(item);
		resetBuilder();
	}

	@NonNull
	public <T, V> ItemBuilder<T, V> property(@NonNull T instance, @GProperty String property) {
		if(null != m_propertyMetaModel)
			throw new IllegalStateException("You need to end the builder pattern with a call to 'control()'");
		m_propertyMetaModel = (PropertyMetaModel<V>) MetaManager.getPropertyMeta(instance.getClass(), property);
		m_instance = instance;
		return new ItemBuilder<>(instance, (PropertyMetaModel<V>) MetaManager.getPropertyMeta(instance.getClass(), property), null);
	}

	@NonNull
	public <T, V> ItemBuilder<T, V> property(@NonNull T instance, @GProperty String property, IBidiBindingConverter<?, V> converter) {
		if(null != m_propertyMetaModel)
			throw new IllegalStateException("You need to end the builder pattern with a call to 'control()'");
		m_propertyMetaModel = MetaManager.getPropertyMeta(instance.getClass(), property);
		m_instance = instance;
		m_bindingConverter = converter;
		return new ItemBuilder<>(instance, (PropertyMetaModel<V>) MetaManager.getPropertyMeta(instance.getClass(), property), converter);
	}

	@NonNull
	public <T, V> ItemBuilder<T, V> property(@NonNull T instance, QField<?, V> property) {
		if(null != m_propertyMetaModel)
			throw new IllegalStateException("You need to end the builder pattern with a call to 'control()'");
		m_propertyMetaModel = MetaManager.getPropertyMeta(instance.getClass(), property);
		m_instance = instance;
		return new ItemBuilder<>(instance, MetaManager.getPropertyMeta(instance.getClass(), property), null);
	}

	@NonNull
	public <T, V> ItemBuilder<T, V> property(@NonNull T instance, QField<?, V> property, IBidiBindingConverter<?, V> converter) {
		if(null != m_propertyMetaModel)
			throw new IllegalStateException("You need to end the builder pattern with a call to 'control()'");
		m_propertyMetaModel = MetaManager.getPropertyMeta(instance.getClass(), property);
		m_instance = instance;
		m_bindingConverter = converter;
		return new ItemBuilder<>(instance, MetaManager.getPropertyMeta(instance.getClass(), property), converter);
	}

	private void resetBuilder() {
		m_readOnly = null;
		m_readOnlyOnce = null;
		m_disabled = null;
		m_disabledOnce = null;
		m_disabledMessage = null;
		m_disabledMessageOnce = null;
		m_instance = null;
		m_propertyMetaModel = null;
		m_append = false;
		m_mandatory = null;
		m_nextLabel = null;
		m_nextLabelControl = null;
		m_controlCss = null;
		m_labelCss = null;
		m_errorLocation = null;
		m_bindingConverter = null;
		m_testid = null;
	}

	/*--------------------------------------------------------------*/
	/*	CODING:	Form building code.									*/
	/*--------------------------------------------------------------*/
	private void addControl(@NonNull NodeBase control) throws Exception {
		if (control.getClass().getSimpleName().contains("TextArea")
			&& m_labelCss == null) {
			m_labelCss = "ui-f4-ta";
		}

		NodeContainer lbl = determineLabel();
		resetDirection();
		m_layouter.addControl(control, lbl, m_controlCss, m_labelCss, m_append);

		String testid = m_testid;
		PropertyMetaModel<?> pmm = m_propertyMetaModel;
		if(null != testid)
			control.setTestID(testid);
		else if(control.getTestID() == null) {
			if(pmm != null)
				control.setTestID(pmm.getName());
		}

		if(control instanceof IControl) {
			IControl< ? > ctl = (IControl< ? >) control;
			if(null != pmm) {
				Object instance = m_instance;
				if(null != instance) {
					IBidiBindingConverter<Object, Object> conv = (IBidiBindingConverter<Object, Object>) m_bindingConverter;
					if(null == conv) {
						control.bind().to(instance, pmm);
					} else {
						BindingBuilderBidi<?> bind = control.bind();
						((BindingBuilderBidi<Object>) bind).to(instance, (PropertyMetaModel<Object>)pmm, conv);
					}
				}
			}

			//-- Do all the readOnly chores
			Boolean readOnly = m_readOnly;
			BindReference<?, Boolean> roOnce = m_readOnlyOnce;
			BindReference<?, Boolean> roGlob = m_readOnlyGlobal;
			if(null != readOnly) {
				ctl.setReadOnly(readOnly.booleanValue());
			} else if(roOnce != null) {
				control.bind("readOnly").to(roOnce);
			} else if(roGlob != null) {
				control.bind("readOnly").to(roGlob);
			}

			//-- Same for disabled - prefer message above the boolean disabled.
			String diMsg = m_disabledMessage;
			BindReference<?, String> diMsgOnce = m_disabledMessageOnce;
			BindReference<?, String> diMsgGlob = m_disabledMessageGlobal;
			Boolean di = m_disabled;
			BindReference<?, Boolean> diOnce = m_disabledOnce;
			BindReference<?, Boolean> diGlob = m_disabledGlobal;

			if(diMsg != null) {
				//ctl.setDisabledBecause(diMsg);			// FIXME
				ctl.setDisabled(true);
			} else if(diMsgOnce != null) {
				control.bind("disabledBecause").to(diMsgOnce);
			} else if(diMsgGlob != null) {
				control.bind("disabledBecause").to(diMsgGlob);
			} else if(di != null) {
				ctl.setDisabled(di.booleanValue());
			} else if(diOnce != null) {
				control.bind("disabled").to(diOnce);
			} else if(diGlob != null) {
				control.bind("disabled").to(diGlob);
			}

			if(isMandatory()) {
				ctl.setMandatory(true);
			}
		}

		String label = labelTextCalculated();
		if (null != m_errorLocation){
			control.setErrorLocation(m_errorLocation);
		} else {
			if(null != label) {
				control.setErrorLocation(label);
			}
		}
		if(null != label)
			control.setCalculcatedId(label.toLowerCase());
	}

	private void resetDirection() {
		if(m_horizontal == m_currentDirection)
			return;
		m_layouter.clear();
		m_currentDirection = m_horizontal;
	}


	public void appendAfterControl(@NonNull NodeBase what) {
		m_layouter.appendAfterControl(what);
	}

	final public class ItemBuilder<I, V> {
		private final I m_instance;

		private final PropertyMetaModel<V> m_propertyMetaModel;

		private final IBidiBindingConverter<?, V> m_converter;

		private String m_nextLabel;

		private String m_errorLocation;

		private NodeContainer m_nextLabelControl;

		private Boolean m_mandatory;

		@Nullable
		private String m_testid;

		/** ReadOnly as set directly in the Builder */
		private Boolean m_readOnly;

		/** When set, the next control's readOnly property will be bound to this reference, after which it will be cleared */
		@Nullable
		private BindReference<?, Boolean> m_readOnlyOnce;

		/** disabled as set directly in the Builder */
		private Boolean m_disabled;

		@Nullable
		private BindReference<?, Boolean> m_disabledOnce;

		/** When set, disable the next component with the specified message. */
		@Nullable
		private String m_disabledMessage;

		@Nullable
		private BindReference<?, String> m_disabledMessageOnce;

		@Nullable
		private String m_controlCss;

		@Nullable
		private String m_labelCss;

		public ItemBuilder(I instance, PropertyMetaModel<V> propertyMeta, IBidiBindingConverter<?, V> converter) {
			m_instance = instance;
			m_propertyMetaModel = propertyMeta;
			m_converter = converter;
		}

		/*----------------------------------------------------------------------*/
		/*	CODING:	Helper code	*/
		/*----------------------------------------------------------------------*/

		@Nullable
		private NodeContainer determineLabel() {
			NodeContainer res = null;
			String txt = m_nextLabel;
			if(null != txt) {
				//m_nextLabel = null;
				if(txt.length() != 0)					// Not "unlabeled"?
					res = new Label(txt);
			} else {
				res = m_nextLabelControl;
				if(res == null) {
					//-- Property known?
					PropertyMetaModel< ? > pmm = m_propertyMetaModel;
					if(null != pmm) {
						txt = pmm.getDefaultLabel();
						if(txt != null && txt.length() > 0)
							res = new Label(txt);
					}
				}
			}
			if(res != null && calculateMandatory() && !isReadOnly()) {
				res.addCssClass("ui-f4-mandatory");
			}

			return res;
		}

		@Nullable
		private String labelTextCalculated() {
			String txt = m_nextLabel;
			if(null != txt) {
				if(txt.length() != 0)					// Not "unlabeled"?
					return txt;
				return null;
			} else {
				NodeContainer res = m_nextLabelControl;
				if(res != null) {
					return res.getTextContents();
				} else {
					//-- Property known?
					PropertyMetaModel< ? > pmm = m_propertyMetaModel;
					if(null != pmm) {
						txt = pmm.getDefaultLabel();
						if(txt != null && txt.length() > 0)
							return txt;
					}
				}
			}
			return null;
		}

		private boolean isReadOnly() {
			Boolean ro = m_readOnly;
			if(null != ro) {
				return ro.booleanValue();
			}
			return false;
		}

		private boolean isMandatory() {
			Boolean man = m_mandatory;
			if(null != man) {
				return man.booleanValue();
			}
			return false;
		}

		private boolean calculateMandatory() {
			Boolean m = m_mandatory;
			if(null != m)
				return m.booleanValue();						// If explicitly set: obey that
			PropertyMetaModel<?> pmm = m_propertyMetaModel;
			if(null != pmm) {
				return pmm.isRequired();
			}
			return false;
		}




		/*--------------------------------------------------------------*/
		/*	CODING:	Label control.										*/
		/*--------------------------------------------------------------*/
		@NonNull
		public ItemBuilder<I, V> label(@NonNull String label) {
			if(null != m_nextLabelControl)
				throw new IllegalStateException("You already set a Label instance");
			m_nextLabel = label;
			return this;
		}

		@NonNull
		public ItemBuilder<I, V> label(@NonNull NodeContainer label) {
			if(null != m_nextLabel)
				throw new IllegalStateException("You already set a String label instance");
			m_nextLabelControl = label;
			return this;
		}

		@NonNull
		public ItemBuilder<I, V> errorLocation(@NonNull String errorLocation) {
			m_errorLocation = errorLocation;
			return this;
		}


		@NonNull
		public ItemBuilder<I, V> unlabeled() {
			label("");
			return this;
		}

		/*--------------------------------------------------------------*/
		/*	CODING:	Readonly, mandatory, disabled.						*/
		/*--------------------------------------------------------------*/
		@NonNull
		public ItemBuilder<I, V> readOnly() {
			m_readOnly = Boolean.TRUE;
			return this;
		}

		/**
		 * Force the next component to have the specified value for readOnly.
		 */
		@NonNull
		public ItemBuilder<I, V> readOnly(boolean ro) {
			m_readOnly = Boolean.valueOf(ro);
			return this;
		}

		/**
		 * Bind only the next component to the specified boolean property. See
		 */
		@NonNull
		public <X> ItemBuilder<I, V> readOnly(@NonNull X instance, @NonNull String property) {
			m_readOnlyOnce = createRef(instance, property, Boolean.class);
			return this;
		}

		/**
		 * Bind only the next component to the specified boolean property. See
		 */
		@NonNull
		public <X> ItemBuilder<I, V> readOnly(@NonNull X instance, @NonNull QField<X, Boolean> property) {
			m_readOnlyOnce = createRef(instance, property);
			return this;
		}

		@NonNull
		public ItemBuilder<I, V> mandatory() {
			m_mandatory = Boolean.TRUE;
			return this;
		}

		@NonNull
		public ItemBuilder<I, V>	mandatory(boolean yes) {
			m_mandatory = Boolean.valueOf(yes);
			return this;
		}

		@NonNull
		public ItemBuilder<I, V> disabled() {
			m_disabled = Boolean.TRUE;
			return this;
		}

		/**
		 * Force the next component to have the specified value for disabled.
		 */
		@NonNull
		public ItemBuilder<I, V> disabled(boolean ro) {
			m_disabled = Boolean.valueOf(ro);
			return this;
		}
		@NonNull
		public ItemBuilder<I, V> testId(String id) {
			m_testid = id;
			return this;
		}

		@NonNull
		public <X> ItemBuilder<I, V> disabled(@NonNull X instance, @NonNull String property) {
			m_disabledOnce = createRef(instance, property, Boolean.class);
			return this;
		}

		@NonNull
		public <X> ItemBuilder<I, V> disabled(@NonNull X instance, @NonNull QField<X, Boolean> property) {
			m_disabledOnce = createRef(instance, property);
			return this;
		}

		/**
		 * Disables the next component with the specified disable message.
		 */
		@NonNull
		public ItemBuilder<I, V> disabledBecause(@Nullable String message) {
			m_disabledMessage = message;
			return this;
		}

		@NonNull
		public <X> ItemBuilder<I, V> disabledBecause(@NonNull X instance, @NonNull String property) {
			m_disabledMessageOnce = createRef(instance, property, String.class);
			return this;
		}

		@NonNull
		public <X> ItemBuilder<I, V> disabledBecause(@NonNull X instance, @NonNull QField<X, String> property) {
			m_disabledMessageOnce = createRef(instance, property);
			return this;
		}

		/**
		 * Adds the specified css class to the control cell.
		 * @param cssClass
		 * @return
		 */
		@NonNull
		public ItemBuilder<I, V> cssControl(@NonNull String cssClass) {
			m_controlCss = cssClass;
			return this;
		}

		/**
		 * Adds the specified css class to the label cell.
		 * @param cssClass
		 * @return
		 */
		@NonNull
		public ItemBuilder<I, V> cssLabel(@NonNull String cssClass) {
			m_labelCss = cssClass;
			return this;
		}


	}



}
