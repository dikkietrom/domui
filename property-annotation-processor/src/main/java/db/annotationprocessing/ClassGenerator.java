package db.annotationprocessing;

import db.annotationprocessing.EntityAnnotationProcessor.Property;

import javax.lang.model.element.Element;
import javax.lang.model.element.TypeElement;
import javax.lang.model.type.DeclaredType;
import javax.lang.model.type.PrimitiveType;
import javax.lang.model.type.ReferenceType;
import javax.lang.model.type.TypeMirror;
import javax.lang.model.util.Elements;
import javax.lang.model.util.Types;
import java.io.IOException;
import java.io.Writer;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

/**
 * @author <a href="mailto:jal@etc.to">Frits Jalvingh</a>
 * Created on 24-3-18.
 */
class ClassGenerator {
	private final EntityAnnotationProcessor m_processor;

	final private Writer m_w;

	final private List<Property> m_properties;

	final private String m_packageName;

	final private String m_className;

	final private String m_entityName;

	private final List<String> m_fieldList = new ArrayList<>();

	private final List<String> m_methodList = new ArrayList<>();

	public ClassGenerator(EntityAnnotationProcessor entityAnnotationProcessor, Writer w, String packageName, String className, List<Property> properties, String entityName) {
		m_processor = entityAnnotationProcessor;
		m_w = w;
		m_packageName = packageName;
		m_className = className;
		m_properties = properties;
		m_entityName = entityName;
	}

	private Types typeUtils() {
		return m_processor.getTypeUtils();
	}

	private Elements elementUtils() {
		return m_processor.getElementUtils();
	}

	private ClassGenerator append(String s) throws IOException {
		m_w.append(s);
		return this;
	}

	public void generate() throws Exception {
		generateClassHeader();

		append("public final class ");
		append(m_className);
		generateClassExtends();
		append(" {\n");


		append("\t");
		append(m_className);
		append("() {\n\t\tsuper(null, null, null);\n\t}\n\n\t");

		generateProperties();

		//append("@Nonnull public QCriteria<");
		//append(cname);
		//append("> getCriteria() throws Exception {\n\t\t");
		//append("validateGetCriteria();\n\t\t");
		//append("return (QCriteria<");
		//append(cname);
		//append(">) criteria();\n\t}");

		append("}\n");
	}

	private void generateProperties() throws Exception {
		for(Property property : m_properties) {
			generateProperty(property);
		}
	}

	private void generateProperty(Property property) throws Exception {
		//-- Now generate the appropriate types.
		if(property.getAnnotationNames().contains("Column") || isSimpleType(property.getType())) {
			generateColumnProperty(property.getType(), property.getName());
		} else if(property.getAnnotationNames().contains("ManyToOne")) {
			generateParentProperty(property.getType(), property.getName());
		} else if(property.getAnnotationNames().contains("OneToMany") || isCollection(property.getType())) {
			generateListProperty(property.getType(), property.getName());
		}
	}

	private void generateClassExtends() {
	}

	private void generateClassHeader() throws IOException {
		append("package ").append(m_packageName).append(";\n");
		append("\n");
		append("import to.etc.webapp.query.*;\n");
		append("import javax.annotation.*;\n");
		append("\n");
		append("@Generated(value = { \"Generated by etc.to PropertyAnnotationProcessor " + EntityAnnotationProcessor.VERSION + "\" })\n");
	}

	private void generateColumnProperty(TypeMirror returnType, String propertyName) throws Exception {
		String mname = EntityAnnotationProcessor.replaceReserved(propertyName);
		if(returnType instanceof PrimitiveType) {
			String retStr = returnType.toString();
			if(retStr.equals("int") || retStr.equals("short")) {
				retStr = "long";
			}
			String mtypeName = Character.toUpperCase(retStr.charAt(0)) + retStr.substring(1);
			m_w.append("\n\n\t@Nonnull\n\tpublic final QField");
			m_w.append(mtypeName);
			m_w.append("<R> ");
			m_w.append(mname);
			m_w.append("() {\n\t\treturn new QField");
			m_w.append(mtypeName);
			m_w.append("<R>(new QField<R, ");
			m_w.append(retStr);
			m_w.append("[]>(m_root, this, \"");
			m_w.append(propertyName);
			m_w.append("\"));\n\t}");

		} else {
			String mtypeName = returnType.toString();

			m_w.append("\n\n\t@Nonnull\n\tpublic final QField<R,");
			m_w.append(mtypeName);
			m_w.append("> ");
			m_w.append(mname);
			m_w.append("() {\n\t\treturn new QField<R,");
			m_w.append(mtypeName);
			m_w.append(">(m_root, this, \"");
			m_w.append(propertyName);
			m_w.append("\");\n\t}");
		}
	}

	private void generateParentProperty(TypeMirror returnType, String propertyName) throws Exception {
		Element mtype = m_processor.getTypeUtils().asElement(returnType);
		String qtype = packName(returnType.toString()) + "." + m_processor.getLinkClass(mtype.getSimpleName().toString());

		String mname = EntityAnnotationProcessor.replaceReserved(propertyName);
		m_w.append("\n\n\t@Nonnull\n\tpublic final ");
		m_w.append(qtype);
		m_w.append("<R> ");
		m_w.append(mname);
		m_w.append("() {\n\t\treturn new ");
		m_w.append(qtype);
		m_w.append("<R>(m_root, this, \"");
		m_w.append(propertyName);
		m_w.append("\");\n\t}");
	}

	private void generateListProperty(TypeMirror returnType, String propertyName) throws Exception {
		DeclaredType rtype = (DeclaredType) returnType;

		DeclaredType rtypeArg = (DeclaredType) rtype.getTypeArguments().iterator().next();
		String rtypeArgName = rtypeArg.asElement().getSimpleName().toString();
		String frtypeArgName = rtypeArg.toString();

		String pack = packName(frtypeArgName);

		String qrtypeArgName = pack + "." + m_processor.getLinkClass(rtypeArgName);

		String mname = EntityAnnotationProcessor.replaceReserved(propertyName);
		m_w.append("\n\n\t@Nonnull\n\tpublic final QList<R,");
		m_w.append(qrtypeArgName);
		m_w.append("Root> ");
		m_w.append(mname);
		m_w.append("() throws Exception {\n\t\treturn new QList<R,");
		m_w.append(qrtypeArgName);
		m_w.append("Root>(");
		m_w.append(qrtypeArgName);
		m_w.append(".get(), this, \"");
		m_w.append(propertyName);
		m_w.append("\");\n\t}");
	}

	/**
	 * True if the type is a simple type (any primitive or primitive wrapper, Date, BigDecimal, BigInteger, String, Enum).
	 */
	private boolean isSimpleType(TypeMirror type) {
		if(type instanceof PrimitiveType)
			return true;
		TypeElement enumElement = elementUtils().getTypeElement("java.lang.Enum");

		if(typeUtils().isSubtype(type, typeUtils().getDeclaredType(enumElement)))
			return true;

		String name = type.toString();
		return SIMPLETYPES.contains(name);
	}

	private boolean isCollection(TypeMirror type) {
		if(! (type instanceof ReferenceType))
			return false;
		TypeElement enumElement = elementUtils().getTypeElement("java.util.Collection");
		if(typeUtils().isSubtype(type, typeUtils().getDeclaredType(enumElement)))
			return true;
		return false;
	}

	private String packName(String frtypeArgName) {
		int dotIndex = frtypeArgName.lastIndexOf('.');
		String pack = "";
		if(dotIndex != -1) {
			pack = frtypeArgName.substring(0, dotIndex);
		}
		return pack;
	}

	static private final Set<String> SIMPLETYPES = new HashSet<>(Arrays.asList("java.lang.Short"
		, "java.lang.Boolean"
		, "java.lang.Byte"
		, "java.lang.Character"
		, "java.lang.Integer"
		, "java.lang.Long"
		, "java.lang.Float"
		, "java.lang.Double"
		, "java.math.BigInteger"
		, "java.math.BigDecimal"
		, "java.lang.String"
		, "java.util.Date"
		, "java.sql.Date"
	));
}
