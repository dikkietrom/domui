package to.etc.domui.component2.form4;

import to.etc.domui.component.binding.BindReference;
import to.etc.domui.component.binding.IBindingConverter;
import to.etc.domui.component.meta.MetaManager;
import to.etc.domui.component.meta.PropertyMetaModel;
import to.etc.domui.component2.controlfactory.ControlCreatorRegistry;
import to.etc.domui.dom.html.IControl;
import to.etc.domui.dom.html.Label;
import to.etc.domui.dom.html.NodeBase;
import to.etc.domui.dom.html.NodeContainer;
import to.etc.domui.dom.html.TD;
import to.etc.domui.server.DomApplication;
import to.etc.domui.util.DomUtil;
import to.etc.webapp.ProgrammerErrorException;
import to.etc.webapp.annotations.GProperty;

import javax.annotation.Nonnull;
import javax.annotation.Nullable;

/**
 * Yet another attempt at a generic form builder, using the Builder pattern. The builder
 * starts in vertical mode - call horizontal() to move horizontally.
 *
 * @author <a href="mailto:jal@etc.to">Frits Jalvingh</a>
 * Created on Jun 17, 2014
 */
final public class FormBuilder {
	/**
	 * Handle adding nodes generated by the form builder to the page.
	 *
	 * @author <a href="mailto:jal@etc.to">Frits Jalvingh</a>
	 * Created on Jun 13, 2012
	 */
	interface IAppender {
		void add(@Nonnull NodeBase formNode);
	}

	@Nonnull
	final private IAppender m_appender;

	private IFormLayouter m_layouter;

	private boolean m_horizontal;

	private boolean m_currentDirection;

	private String m_nextLabel;

	private String m_errorLocation;

	private NodeContainer m_nextLabelControl;

	private PropertyMetaModel< ? > m_propertyMetaModel;

	private Object m_instance;

	private Boolean m_mandatory;

	private boolean m_append;

	@Nullable
	private String m_testid;

	/** ReadOnly as set directly in the Builder */
	private Boolean m_readOnly;

	/** When set, the next control's readOnly property will be bound to this reference, after which it will be cleared */
	@Nullable
	private BindReference<?, Boolean> m_readOnlyOnce;

	/** While set, all controls added will have their readOnly property bound to this reference unless otherwise specified */
	@Nullable
	private BindReference<?, Boolean> m_readOnlyGlobal;

	/** When set, disable the next component with the specified message. */
	@Nullable
	private String m_disabledMessage;

	@Nullable
	private BindReference<?, String> m_disabledMessageOnce;

	@Nullable
	private BindReference<?, String> m_disabledMessageGlobal;

	/** disabled as set directly in the Builder */
	private Boolean m_disabled;

	@Nullable
	private BindReference<?, Boolean> m_disabledOnce;

	@Nullable
	private BindReference<?, Boolean> m_disabledGlobal;


	private NodeBase m_lastAddedControl;

	@Nullable
	private String m_controlCss;

	@Nullable
	private String m_labelCss;

	@Nullable
	private IBindingConverter<?, ?> m_bindingConverter;

	public FormBuilder(@Nonnull IAppender appender) {
		m_appender = appender;
		m_layouter = new TableFormLayouter(appender);
	}

	public FormBuilder(@Nonnull IFormLayouter layout, @Nonnull IAppender appender) {
		m_appender = appender;
		m_layouter = layout;
	}

	public FormBuilder(@Nonnull final NodeContainer nb) {
		this(nb::add);
	}

	@Nonnull
	public FormBuilder append() {
		m_append = true;
		return this;
	}


	public FormBuilder nl() {
		m_layouter.clear();
		return this;
	}

	@Nonnull
	public FormBuilder horizontal() {
		m_horizontal = true;
		m_layouter.setHorizontal(true);
		return this;
	}

	@Nonnull
	public FormBuilder vertical() {
		m_horizontal = false;
		m_layouter.setHorizontal(false);
		return this;
	}

	static private <I, V> BindReference<I, V> createRef(@Nonnull I instance, @Nonnull String property, @Nonnull Class<V> type) {
		PropertyMetaModel<?> pmm = MetaManager.getPropertyMeta(instance.getClass(), property);
		if(DomUtil.getBoxedForPrimitive(pmm.getActualType()) != DomUtil.getBoxedForPrimitive(type)) {
			throw new ProgrammerErrorException(pmm + " must be of type " + type.getName());
		}
		return new BindReference<>(instance, (PropertyMetaModel<V>) pmm);

	}

	/*--------------------------------------------------------------*/
	/*	CODING:	Label control.										*/
	/*--------------------------------------------------------------*/
	@Nonnull
	public FormBuilder label(@Nonnull String label) {
		if(null != m_nextLabelControl)
			throw new IllegalStateException("You already set a Label instance");
		m_nextLabel = label;
		return this;
	}

	@Nonnull
	public FormBuilder label(@Nonnull NodeContainer label) {
		if(null != m_nextLabel)
			throw new IllegalStateException("You already set a String label instance");
		m_nextLabelControl = label;
		return this;
	}

	@Nonnull
	public FormBuilder errorLocation(@Nonnull String errorLocation) {
		m_errorLocation = errorLocation;
		return this;
	}


	@Nonnull
	public FormBuilder unlabeled() {
		label("");
		return this;
	}

	/*--------------------------------------------------------------*/
	/*	CODING:	Readonly, mandatory, disabled.						*/
	/*--------------------------------------------------------------*/
	@Nonnull
	public FormBuilder readOnly() {
		m_readOnly = Boolean.TRUE;
		return this;
	}

	/**
	 * Force the next component to have the specified value for readOnly.
	 */
	@Nonnull
	public FormBuilder readOnly(boolean ro) {
		m_readOnly = Boolean.valueOf(ro);
		return this;
	}


	/**
	 * Bind only the next component to the specified boolean property. See
	 */
	@Nonnull
	public <I> FormBuilder readOnly(@Nonnull I instance, @Nonnull String property) {
		m_readOnlyOnce = createRef(instance, property, Boolean.class);
		return this;
	}

	/**
	 * By default bind all next components' readOnly property to the specified Boolean property. This binding
	 * takes effect except if a more detailed readOnly binding is specified.
	 */
	@Nonnull
	public <I> FormBuilder readOnlyAll(@Nonnull I instance, @Nonnull String property) {
		m_readOnlyGlobal = createRef(instance, property, Boolean.class);
		return this;
	}

	/**
	 * Clear the global "read only" binding as set by {@link #readOnlyAll(Object, String)}, so that components
	 * after this are no longer bound to the previously set property.
	 */
	@Nonnull
	public FormBuilder readOnlyAllClear() {
		m_readOnlyGlobal = null;
		return this;
	}

	@Nonnull
	public FormBuilder disabled() {
		m_disabled = Boolean.TRUE;
		return this;
	}

	/**
	 * Force the next component to have the specified value for disabled.
	 */
	@Nonnull
	public FormBuilder disabled(boolean ro) {
		m_disabled = Boolean.valueOf(ro);
		return this;
	}
	@Nonnull
	public FormBuilder testId(String id) {
		m_testid = id;
		return this;
	}

	@Nonnull
	public <I> FormBuilder disabled(@Nonnull I instance, @Nonnull String property) {
		m_disabledOnce = createRef(instance, property, Boolean.class);
		return this;
	}

	/**
	 * By default bind all next components' disabled property to the specified Boolean property. This binding
	 * takes effect except if a more detailed binding is specified.
	 */
	@Nonnull
	public <I> FormBuilder disabledAll(@Nonnull I instance, @Nonnull String property) {
		m_disabledGlobal = createRef(instance, property, Boolean.class);
		return this;
	}

	/**
	 * Clear the global "disabled" binding as set by {@link #disabledAll(Object, String)}, so that components
	 * after this are no longer bound to the previously set property.
	 */
	@Nonnull
	public FormBuilder disabledAllClear() {
		m_disabledGlobal = null;
		return this;
	}

	/**
	 * Disables the next component with the specified disable message.
	 */
	@Nonnull
	public FormBuilder disabledBecause(@Nullable String message) {
		m_disabledMessage = message;
		return this;
	}

	@Nonnull
	public <I> FormBuilder disabledBecause(@Nonnull I instance, @Nonnull String property) {
		m_disabledMessageOnce = createRef(instance, property, String.class);
		return this;
	}

	@Nonnull
	public <I> FormBuilder disabledBecauseAll(@Nonnull I instance, @Nonnull String property) {
		m_disabledMessageGlobal = createRef(instance, property, String.class);
		return this;
	}

	@Nonnull
	public FormBuilder disabledBecauseClear() {
		m_disabledMessageGlobal = null;
		return this;
	}

	@Nonnull
	public FormBuilder mandatory() {
		m_mandatory = Boolean.TRUE;
		return this;
	}

	@Nonnull
	public FormBuilder	mandatory(boolean yes) {
		m_mandatory = Boolean.valueOf(yes);
		return this;
	}

	/*--------------------------------------------------------------*/
	/*	CODING: defining (manually created) controls.				*/
	/*--------------------------------------------------------------*/
	/**
	 * Add the specified control. Since the control is manually created this code assumes that the
	 * control is <b>properly configured</b> for it's task! This means that this code will not
	 * make any changes to the control! Specifically: if the form item is marked as "mandatory"
	 * but the control here is not then the control stays optional.
	 * The reverse however is not true: if the control passed in is marked as mandatory then the
	 * form item will be marked as such too.
	 */
	public void control(@Nonnull IControl< ? > control) throws Exception {
		if(control.isMandatory()) {
			m_mandatory = Boolean.TRUE;
		}
		addControl((NodeBase) control);
		resetBuilder();
	}

	@Nonnull
	public IControl< ? > control() throws Exception {
		return controlMain(null);
	}

	@Nonnull
	public <T, C extends IControl<T>> C control(@Nullable Class<C> controlClass) throws Exception {
		return controlMain(controlClass);
	}

	@Nonnull
	private  <T, C extends IControl<T>> C controlMain(@Nullable Class<C> controlClass) throws Exception {
		ControlCreatorRegistry builder = DomApplication.get().getControlCreatorRegistry();
		PropertyMetaModel<T> pmm = (PropertyMetaModel<T>) m_propertyMetaModel;
		if(null == pmm)
			throw new IllegalStateException("You must have called 'property(...)' before");
		C control = builder.createControl(pmm, controlClass);
		addControl((NodeBase) control);
		resetBuilder();
		return control;
	}

	@Nonnull
	public FormBuilder converter(@Nonnull IBindingConverter<?, ?> converter) {
		m_bindingConverter = converter;
		return this;
	}

	/**
	 * Adds the specified css class to the control cell.
	 * @param cssClass
	 * @return
	 */
	@Nonnull
	public FormBuilder cssControl(@Nonnull String cssClass) {
		m_controlCss = cssClass;
		return this;
	}

	/**
	 * Adds the specified css class to the label cell.
	 * @param cssClass
	 * @return
	 */
	@Nonnull
	public FormBuilder cssLabel(@Nonnull String cssClass) {
		m_labelCss = cssClass;
		return this;
	}

	public void item(@Nonnull NodeBase item) throws Exception {
		addControl(item);
		resetBuilder();
	}

	@Nonnull
	public <T> FormBuilder property(@Nonnull T instance, @GProperty String property) {
		if(null != m_propertyMetaModel)
			throw new IllegalStateException("You need to end the builder pattern with a call to 'control()'");
		m_propertyMetaModel = MetaManager.getPropertyMeta(instance.getClass(), property);
		m_instance = instance;
		return this;
	}

	private void resetBuilder() {
		m_readOnly = null;
		m_readOnlyOnce = null;
		m_disabled = null;
		m_disabledOnce = null;
		m_disabledMessage = null;
		m_disabledMessageOnce = null;
		m_instance = null;
		m_propertyMetaModel = null;
		m_append = false;
		m_mandatory = null;
		m_nextLabel = null;
		m_nextLabelControl = null;
		m_controlCss = null;
		m_labelCss = null;
		m_errorLocation = null;
		m_bindingConverter = null;
		m_testid = null;
	}

	/*--------------------------------------------------------------*/
	/*	CODING:	Form building code.									*/
	/*--------------------------------------------------------------*/
	private void addControl(@Nonnull NodeBase control) throws Exception {
		if (control.getClass().getSimpleName().contains("TextArea")
			&& m_labelCss == null) {
			m_labelCss = "ui-f4-ta";
		}

		NodeContainer lbl = determineLabel();
		resetDirection();
		m_layouter.addControl(control, lbl, m_controlCss, m_labelCss);

		String testid = m_testid;
		PropertyMetaModel<?> pmm = m_propertyMetaModel;
		if(null != testid)
			control.setTestID(testid);
		else if(control.getTestID() == null) {
			if(pmm != null)
				control.setTestID(pmm.getName());
		}

		if(control instanceof IControl) {
			IControl< ? > ctl = (IControl< ? >) control;
			if(null != pmm) {
				Object instance = m_instance;
				if(null != instance) {
					((NodeBase) ctl).bind().convert(m_bindingConverter).to(instance, pmm);
				}
			}

			//-- Do all the readOnly chores
			Boolean readOnly = m_readOnly;
			BindReference<?, Boolean> roOnce = m_readOnlyOnce;
			BindReference<?, Boolean> roGlob = m_readOnlyGlobal;
			if(null != readOnly) {
				ctl.setReadOnly(readOnly.booleanValue());
			} else if(roOnce != null) {
				control.bind("readOnly").to(roOnce);
			} else if(roGlob != null) {
				control.bind("readOnly").to(roGlob);
			}

			//-- Same for disabled - prefer message above the boolean disabled.
			String diMsg = m_disabledMessage;
			BindReference<?, String> diMsgOnce = m_disabledMessageOnce;
			BindReference<?, String> diMsgGlob = m_disabledMessageGlobal;
			Boolean di = m_disabled;
			BindReference<?, Boolean> diOnce = m_disabledOnce;
			BindReference<?, Boolean> diGlob = m_disabledGlobal;

			if(diMsg != null) {
				//ctl.setDisabledBecause(diMsg);			// FIXME
				ctl.setDisabled(true);
			} else if(diMsgOnce != null) {
				control.bind("disabledBecause").to(diMsgOnce);
			} else if(diMsgGlob != null) {
				control.bind("disabledBecause").to(diMsgGlob);
			} else if(di != null) {
				ctl.setDisabled(di.booleanValue());
			} else if(diOnce != null) {
				control.bind("disabled").to(diOnce);
			} else if(diGlob != null) {
				control.bind("disabled").to(diGlob);
			}

			if(isMandatory()) {
				ctl.setMandatory(true);
			}
		}

		String label = labelTextCalculated();
		m_lastAddedControl =  control;
		if (null != m_errorLocation){
			control.setErrorLocation(m_errorLocation);
		} else {
			if(null != label) {
				control.setErrorLocation(label);
			}
		}
		if(null != label)
			control.setCalculcatedId(label.toLowerCase());
	}

	private void resetDirection() {
		if(m_horizontal == m_currentDirection)
			return;
		m_layouter.clear();
		m_currentDirection = m_horizontal;
	}


	public void appendAfterControl(@Nonnull NodeBase what) {
		getLastControlCell().add(what);
	}

	@Nonnull
	public NodeContainer getLastControlCell() {
		if (m_lastAddedControl == null) {
			throw new IllegalStateException("No controls were added yet.");
		}
		return m_lastAddedControl.getParent(TD.class);
	}

	@Nullable
	private NodeContainer determineLabel() {
		NodeContainer res = null;
		String txt = m_nextLabel;
		if(null != txt) {
			//m_nextLabel = null;
			if(txt.length() != 0)					// Not "unlabeled"?
				res = new Label(txt);
		} else {
			res = m_nextLabelControl;
			if(res == null) {
				//-- Property known?
				PropertyMetaModel< ? > pmm = m_propertyMetaModel;
				if(null != pmm) {
					txt = pmm.getDefaultLabel();
					if(txt != null && txt.length() > 0)
						res = new Label(txt);
				}
			}
		}
		if(res != null && calculateMandatory() && !isReadOnly()) {
			res.addCssClass("ui-f4-mandatory");
		}

		return res;
	}

	@Nullable
	private String labelTextCalculated() {
		String txt = m_nextLabel;
		if(null != txt) {
			if(txt.length() != 0)					// Not "unlabeled"?
				return txt;
			return null;
		} else {
			NodeContainer res = m_nextLabelControl;
			if(res != null) {
				return res.getTextContents();
			} else {
				//-- Property known?
				PropertyMetaModel< ? > pmm = m_propertyMetaModel;
				if(null != pmm) {
					txt = pmm.getDefaultLabel();
					if(txt != null && txt.length() > 0)
						return txt;
				}
			}
		}
		return null;
	}

	private boolean isReadOnly() {
		Boolean ro = m_readOnly;
		if(null != ro) {
			return ro.booleanValue();
		}
		return false;
	}

	private boolean isMandatory() {

		Boolean man = m_mandatory;
		if(null != man) {
			return man.booleanValue();
		}
		return false;
	}

	private boolean calculateMandatory() {
		Boolean m = m_mandatory;
		if(null != m)
			return m.booleanValue();						// If explicitly set: obey that
		PropertyMetaModel<?> pmm = m_propertyMetaModel;
		if(null != pmm) {
			return pmm.isRequired();
		}
		return false;
	}


}
