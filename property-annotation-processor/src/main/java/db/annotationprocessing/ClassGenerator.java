package db.annotationprocessing;

import db.annotationprocessing.EntityAnnotationProcessor.Property;

import javax.annotation.processing.Messager;
import javax.lang.model.element.AnnotationMirror;
import javax.lang.model.element.Element;
import javax.lang.model.element.TypeElement;
import javax.lang.model.type.DeclaredType;
import javax.lang.model.type.PrimitiveType;
import javax.lang.model.type.ReferenceType;
import javax.lang.model.type.TypeMirror;
import javax.lang.model.util.Elements;
import javax.lang.model.util.Types;
import javax.tools.Diagnostic.Kind;
import java.io.IOException;
import java.io.Writer;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

/**
 * @author <a href="mailto:jal@etc.to">Frits Jalvingh</a>
 * Created on 24-3-18.
 */
abstract class ClassGenerator {
	protected final EntityAnnotationProcessor m_processor;

	final protected Writer m_w;

	final private List<Property> m_properties;

	final private String m_packageName;

	final private String m_className;

	final private String m_targetClassName;

	private final List<String> m_fieldList = new ArrayList<>();

	private final List<String> m_methodList = new ArrayList<>();

	protected ClassGenerator(EntityAnnotationProcessor entityAnnotationProcessor, Writer w, String packageName, String className, List<Property> properties, String targetClassName) {
		m_processor = entityAnnotationProcessor;
		m_w = w;
		m_packageName = packageName;
		m_className = className;
		m_properties = properties;
		m_targetClassName = targetClassName;
	}

	protected Types typeUtils() {
		return m_processor.getTypeUtils();
	}

	protected Elements elementUtils() {
		return m_processor.getElementUtils();
	}

	protected Messager getMessager() {
		return m_processor.getMessager();
	}

	public String getClassName() {
		return m_className;
	}

	public String getTargetClassName() {
		return m_targetClassName;
	}

	protected ClassGenerator append(String s) throws IOException {
		m_w.append(s);
		return this;
	}

	public void generate() throws Exception {
		generateClassHeader();

		append("public class ");
		append(m_className);
		generateClassExtends();
		append(" {\n");

		generateConstructor();

		generateProperties();
		append("}\n");
	}

	protected void generateConstructor() throws IOException {
		append("\t").append(m_className).append("() {\n");
		append("\n");
		append("\t}\n");
	}

	private void generateProperties() throws Exception {
		for(Property property : m_properties) {
			generateProperty(property);
		}
	}

	private void generateProperty(Property property) throws Exception {
		if(IGNORED_PROPERTIES.contains(property.getName()))
			return;

		//-- Now generate the appropriate types.
		if(property.getAnnotationNames().contains("Column") || isSimpleType(property.getType())) {
			generateColumnProperty(property.getType(), property.getName());
		} else if(isCollection(property.getType())) {
			//-- todo
		} else {
			Element mtype = typeUtils().asElement(property.getType());
			//System.out.println("ANN: elementType " + property + " is " + mtype);
			getMessager().printMessage(Kind.WARNING, "ANN: elementType " + property + " is " + mtype);
			if(! hasAnnotation(mtype, EntityAnnotationProcessor.GENERATED_PROPERTIES_ANNOTATION)
				&& ! hasAnnotation(mtype, EntityAnnotationProcessor.PERSISTENCE_ANNOTATION))
				return;

			generateParentProperty(property.getType(), property.getName());
		}
	}

	protected void generateClassExtends() throws IOException {
	}

	private void generateClassHeader() throws IOException {
		append("package ").append(m_packageName).append(";\n");
		append("\n");
		append("import to.etc.webapp.query.*;\n");
		append("import javax.annotation.*;\n");
		append("\n");
		append("@Generated(value = { \"Generated by etc.to PropertyAnnotationProcessor " + EntityAnnotationProcessor.VERSION + "\" })\n");
	}

	abstract protected void generateColumnProperty(TypeMirror returnType, String propertyName) throws Exception;

	abstract protected void generateParentProperty(TypeMirror returnType, String propertyName) throws Exception;

	protected void generateListProperty(TypeMirror returnType, String propertyName) throws Exception {
		DeclaredType rtype = (DeclaredType) returnType;

		DeclaredType rtypeArg = (DeclaredType) rtype.getTypeArguments().iterator().next();
		String rtypeArgName = rtypeArg.asElement().getSimpleName().toString();
		String frtypeArgName = rtypeArg.toString();

		String pack = packName(frtypeArgName);

		String qrtypeArgName = pack + "." + m_processor.getLinkClass(rtypeArgName);

		String mname = replaceReserved(propertyName);
		m_w.append("\n\n\t@Nonnull\n\tpublic final QList<R,");
		m_w.append(qrtypeArgName);
		m_w.append("Root> ");
		m_w.append(mname);
		m_w.append("() throws Exception {\n\t\treturn new QList<R,");
		m_w.append(qrtypeArgName);
		m_w.append("Root>(");
		m_w.append(qrtypeArgName);
		m_w.append(".get(), this, \"");
		m_w.append(propertyName);
		m_w.append("\");\n\t}");
	}

	/**
	 * True if the type is a simple type (any primitive or primitive wrapper, Date, BigDecimal, BigInteger, String, Enum).
	 */
	protected boolean isSimpleType(TypeMirror type) {
		if(type instanceof PrimitiveType)
			return true;
		TypeElement enumElement = elementUtils().getTypeElement("java.lang.Enum");

		if(typeUtils().isSubtype(type, typeUtils().getDeclaredType(enumElement)))
			return true;

		String name = type.toString();
		return SIMPLETYPES.contains(name);
	}

	protected boolean isCollection(TypeMirror type) {
		if(! (type instanceof ReferenceType))
			return false;
		TypeElement enumElement = elementUtils().getTypeElement("java.util.Collection");
		if(typeUtils().isSubtype(type, typeUtils().getDeclaredType(enumElement)))
			return true;
		return false;
	}

	protected String packName(String frtypeArgName) {
		int dotIndex = frtypeArgName.lastIndexOf('.');
		String pack = "";
		if(dotIndex != -1) {
			pack = frtypeArgName.substring(0, dotIndex);
		}
		return pack;
	}

	protected boolean hasAnnotation(Element type, String annotationName) {
		for(AnnotationMirror mirror : type.getAnnotationMirrors()) {
			String annName = mirror.getAnnotationType().asElement().toString();
			if(annotationName.equals(annName))
				return true;
		}
		return false;
	}

	protected String getStaticClassName() {
		return m_processor.getStaticClass(m_targetClassName);
	}

	protected String getRootClassName() {
		return m_processor.getRootClass(m_targetClassName);
	}

	protected String getLinkClass() {
		return m_processor.getLinkClass(m_targetClassName);
	}

	static private final Set<String> IGNORED_PROPERTIES = new HashSet<>(Arrays.asList(
		"class"
	));

	static private final Set<String> SIMPLETYPES = new HashSet<>(Arrays.asList("java.lang.Short"
		, "java.lang.Boolean"
		, "java.lang.Byte"
		, "java.lang.Character"
		, "java.lang.Integer"
		, "java.lang.Long"
		, "java.lang.Float"
		, "java.lang.Double"
		, "java.math.BigInteger"
		, "java.math.BigDecimal"
		, "java.lang.String"
		, "java.util.Date"
		, "java.sql.Date"
	));

	/**
	 * If the type is primitive return its wrapper type.
	 */
	static String getWrappedType(String type) {
		String w = WRAPPER_MAP.get(type);
		return w == null ? type : w;
	}

	static String replaceReserved(String s) {
		if(m_reserved.contains(s)) {
			return s + "_";
		}
		return s;
	}

	static final Set<String> m_reserved = new HashSet<String>();

	static {
		m_reserved.add("abstract");
		m_reserved.add("assert");
		m_reserved.add("boolean ");
		m_reserved.add("break ");
		m_reserved.add("byte");
		m_reserved.add("case");
		m_reserved.add("catch");
		m_reserved.add("char");
		m_reserved.add("class");
		m_reserved.add("const");
		m_reserved.add("continue");
		m_reserved.add("default");
		m_reserved.add("double");
		m_reserved.add("do");
		m_reserved.add("else");
		m_reserved.add("enum");
		m_reserved.add("extends");
		m_reserved.add("false");
		m_reserved.add("final");
		m_reserved.add("finally");
		m_reserved.add("float");
		m_reserved.add("for");
		m_reserved.add("goto");
		m_reserved.add("if");
		m_reserved.add("implements");
		m_reserved.add("import");
		m_reserved.add("instanceof");
		m_reserved.add("int");
		m_reserved.add("interface");
		m_reserved.add("long");
		m_reserved.add("native");
		m_reserved.add("new");
		m_reserved.add("null");
		m_reserved.add("package");
		m_reserved.add("private");
		m_reserved.add("protected");
		m_reserved.add("public");
		m_reserved.add("return");
		m_reserved.add("short");
		m_reserved.add("static");
		m_reserved.add("strictfp");
		m_reserved.add("super");
		m_reserved.add("switch");
		m_reserved.add("synchronized");
		m_reserved.add("this");
		m_reserved.add("throw");
		m_reserved.add("throws");
		m_reserved.add("transient");
		m_reserved.add("true");
		m_reserved.add("try");
		m_reserved.add("void");
		m_reserved.add("volatile");
		m_reserved.add("while");

	}


	static private final Map<String, String> WRAPPER_MAP = new HashMap<>();

	static {
		WRAPPER_MAP.put("boolean", "java.lang.Boolean");
		WRAPPER_MAP.put("byte", "java.lang.Byte");
		WRAPPER_MAP.put("char", "java.lang.Character");
		WRAPPER_MAP.put("int", "java.lang.Integer");
		WRAPPER_MAP.put("long", "java.lang.Long");
		WRAPPER_MAP.put("float", "java.lang.Float");
		WRAPPER_MAP.put("double", "java.lang.Double");
		//WRAPPER_MAP.put("", "java.lang.");
		//WRAPPER_MAP.put("", "java.lang.");
		//WRAPPER_MAP.put("", "java.lang.");
	}


}
